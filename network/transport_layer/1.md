# TCP报文格式
![image](https://user-images.githubusercontent.com/56379080/183858734-49dc9f27-7719-45c7-b5f1-648158de4614.png)

- Seq字段：，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记
- Ack字段：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1
- Flag字段
    - ACK：确认序号有效。
    - SYN：发起一个新连接。
    - FIN：释放一个连接
    - RST：重置连接

# 三次握手
![image](https://user-images.githubusercontent.com/56379080/183858900-1f071dc7-bcfd-499c-b307-af706dc5a37b.png)
1.	客户端向服务器端发送一段TCP报文
    - 标志位为SYN，代表请求建立新连接
    - Seq=X
2.	服务器端结束Listen阶段
    - 标志位为SYN与ACK，表示：确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接
    - Seq=Y
    - ACK=X+1
3.	客户端结束SYN SENT阶段
    - 标志位为ACK，表示“确认收到服务器端同意连接的信号”
    - Seq=X+1
    - ACK=Y+1
    - 客户端进入ESTABLISHED阶段

# 为什么要三次握手？
为了验证全双工通信的双向联通性，如果只是2次握手，那么只能证明（客户端服务器）的连接是畅通的，服务器并不知道(服务器客户端)这个连接是否畅通

# 四次挥手
![image](https://user-images.githubusercontent.com/56379080/183859262-9fef1395-cbfe-470c-aa44-b050740e1a1f.png)
1.	客户端想结束连接
    - 标记位为FIN，表示请求释放连接
    - Seq=U
2.	服务端进入CLOSE WAIT阶段（半关闭状态）
    - 标记位为ACK
    - Seq=V
    - Ack=U+1
3.	服务器端准备释放连接
    - ACK、FIN位被置位
    - Seq=W
    - Ack=U+1
4.	客户端释放连接
    - 标记位为ACK
    - Seq=U+1
    - Ack=W+1

# TIME_WAIT阶段
如果最后一个包丢失，那么在2MSL时间内服务器会重新发送FIN包，如果没丢失那么就啥也不会发

MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。


# 如何使用UDP模拟TCP？TCP可靠通信？

如果用UDP实现TCP功能，需要增加以下结构

1.	增加ack机制，确保能发送到对端
2.	增加seq机制，实现顺序化传输
3.	需要用队列实现缓冲区，主要是为了重传
4.	校验机制

还需要增加以下几个机制：
1.	重传机制
    - 普通重传：等待定时器超时还没收到ACK
    - 快重传：在监测到3次相同的ACK后就启动重传，而不等待定时器超时
2.	滑动窗口
    - 用来确定到底传输哪些数据包
4.	流量控制
    - 防止过快的发送占满了对方的缓冲区：如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。
    - 主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。
    - 当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。
4.	拥塞控制
    - 防止过快的发送使得网络拥挤：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
    - ![image](https://user-images.githubusercontent.com/56379080/183860033-ed006c66-03cf-4cf5-a2ce-3688d6a2286a.png)
	 

## 为啥现在很多都自己实现TCP协议？
答：因为慢启动和拥塞避免的缺点。

## 在哪一层进行封装？
答：在应用层。下一层的功能要用上一层来进行封装。

# 快重传
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图
![image](https://user-images.githubusercontent.com/56379080/183860210-a3a890cc-5820-4ac4-97db-2bbacd72da2d.png)












