# 前言
最近看了下计算机组成原理的书，发现了一个问题：众所周知，在冯诺依曼架构下有5个组成部件，分别是I/O设备、计算单元、存储单元、控制单元，这里面控制单元是干啥的？CPU本来就是用来控制的，为啥里面还有一个控制单元？这不成套娃了吗？
于是怀着这个疑问我开始了探索，也就有了这篇文章，这篇文章只能说是大概的讲述了CPU识别代码的工作原理，而那些分支预测、流水线、多发射、缓存预取的东西都将在别的篇章讲到，这篇主要就解决一个问题：CPU是如何进行下方这段代码的计算的。
```
MOV eax, 3
ADD eax, 1
```

# 总体介绍
这是我在油管上看到的讲解还算是比较简单易懂的版本，可以先看看这个视频再往下继续看文章。
<iframe width="960" height="540" src="https://www.youtube.com/embed/cNN_tTXABUA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# 运行细节
## 上古时代
上古时代没有指令可言，一切都是开关，那时候的计算机是这样的：
[![ouA6OJ.jpg](https://z3.ax1x.com/2021/11/28/ouA6OJ.jpg)](https://imgtu.com/i/ouA6OJ)
每一次进行一个操作就需要重新接线，比如说现在有一个输入数据存放在`EAX`寄存器中，另一个输入数据存放在`EBX`中，想把两个输入数据之和存放到`ECX`寄存器中，需要这样做：
1. 设置EAX值
    - 拨码器设置3
    - 按动set位，将值存放到EAX中
2. 设置EBX值
    - 拨码器设置1
    - 按动set位，将值存放到EBX中
3. 计算
    - 设置EAX的enable位，让它把数据广播到总线上
    - 设置ALU的Temporary寄存器的set位，从总线上接收数据
    - 设置EBX的enable位，设置ALU的enable位，ALU输出寄存器的set位
4. 存储
    - 设置ECX的set位，设置ALU输出寄存器的enable位

这样的话在ECX中就存储了3+1的值4，那么我想计算10+12的时候就还需要手动设置一遍这个流程才能得到结果，可以看到这样是非常繁琐而且容易出错的，因此人们就需要想一种方法来减少人工的操作。

## 中古时代
[![ouiqwq.png](https://z3.ax1x.com/2021/11/28/ouiqwq.png)](https://imgtu.com/i/ouiqwq)

### 单条指令执行
人们发现所有的接线工作其实都是有迹可循的（比如说存一个值就只需要把寄存器的set位打开，设置内存地址值，设置内存的enable位，把数据从内存经由总线设置到寄存中就可以了），所以可以使用集成电路来控制这些开关，不仅准确而且线路更稳定，使用集成电路来控制的原理也很简单，输入指令的每一位都与一个部件相连，如果输入指令对应位为1那么就激活，否则就不激活。

上面的设计很美好，但是有一个问题，那就是硬件与软件是强绑定的，软件没有软件层面的抽象，我每一次编程还是需要考虑开关哪个寄存器，这将大大阻碍软件的开发，于是人们做了一个中间层：译码器（又叫做Control Unit），来解耦软件与硬件

[![译码器](https://z3.ax1x.com/2021/11/28/oungmD.jpg)](https://imgtu.com/i/oungmD)
如上图所示，这就是一个单周期的计算机的译码器，它负责将传入的二进制指令转换为一些电路的开关，从而完成计算。

这样的话，上层的输入指令也有了自由设计的空间，后来叫做控制字，所有控制字的集合叫做指令集。下面就给出这些控制字的二进制表示和作用，有兴趣的可以将下图的二进制指令带入到上图的译码器中，观察一下是哪些部件被激活了。
[![控制字](https://z3.ax1x.com/2021/11/28/oun6OO.jpg)](https://imgtu.com/i/oun6OO)

后来编程的时候人们又发现人脑是记不住那么复杂的控制字的，那怎么办呢？于是助记符也就是汇编应运而生，汇编编译为可执行程序的时候直接可以一对一的翻译，比如MOV指令就可以直接翻译成`0100000`二进制序列。
后来人们又发现汇编也很麻烦，每次都需要控制寄存器的状态，所以就发明了C语言来简化开发，至于后来人们嫌弃C语言还是太底层转而开发出Java等自带GC的语言那就更是后话，这里还有一个时代大背景那就是机器成本的不断下降，人员成本占整个软件开发成本地不断上升。

**正如我们难以想象人猿祖先是如何茹毛饮血的，现在的开发者也很难想象当初的编程竟然是不断地按开关、接电线。**

### 指令连续执行与跳转
在计算机内还有PC、MAR、MDR、IR寄存器来实现指令连续执行与跳转（说白了指令跳转也差不多是指令连续执行的一种，只不过它的执行地址不是+1那么简单）。

**名词解释**
- PC：Programma Counter，存放下一条指令的地址
- MAR：Memory Address Register，存放要{读/写}的内存地址
- MDR：Memory Data Register，存放数据，将要被写到内存或者刚从内存中读取出来
- IR：Instruction Register，指令寄存器
- ALU：Arithmetic Logic Unit，数学计算单元

这样的话就可以把程序编写到一块内存之中，每次执行PC指向的地址的指令就好，这样就实现了程序执行的连贯。

但是程序并不是简单的从头走到尾的，需要一些逻辑判断来进行分支跳转，那这是怎么实现的呢？这就不得不提一下分支跳转的指令设计：
[![指令类型](https://z3.ax1x.com/2021/11/28/ouKyZD.jpg)](https://imgtu.com/i/ouKyZD)
指令一共有3种类型，分支跳转指令内含不同条件下跳转的地址。

## 现代
[![oPai90.gif](https://z3.ax1x.com/2021/11/24/oPai90.gif)](https://imgtu.com/i/oPai90)
