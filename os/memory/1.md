# 综述
## 实模式时代
早期的8086处理器寄存器宽度只有16位，16位的寄存器只能进行64KB的寻址，而8086有20根地址线，按照地址线来计算可以进行 1 MB 的寻址，所以16位宽度的寄存器是显然不能满足需求的，为了解决这个问题，提出了用`段基址:段内偏移`的方式来扩展寻址空间，即`物理地址 = 段基址 << 4 + 段内偏移`。在实模式下，段寄存器直接存放的就是段基址，比如CPU 中用来存放当前指令地址的`CS:IP`寄存器，CS 中存放的便是代码段的基址。那么实模式有什么缺陷呢？首先就是不安全，程序可以随意访问任何物理地址，进程之间没有隔离也没有特权级概念，因此病毒很容易就可以干掉操作系统。

## 保护模式时代
后来为了解决实模式具有的问题，CPU设计者引入了保护模式的概念，在保护模式下，很重要的一点就是段寄存器不是直接存放段基址了，而是存放着段选择子。段选择子其实就是一个索引，用来索引段描述符，段描述符用来描述一个段的信息。长度为64位，其中有32位用来存放段基址，剩下32位存放着段界限等信息，段描述符又放在全局描述表(Global Discriptor Table)中，GDT的结构如下图所示：

![GDT表项含义](https://user-images.githubusercontent.com/56379080/145165586-539d6581-f18b-4322-ab12-1768d2fc14fb.png)

GDT的地址在操作系统初始化的时候就使用`lgdt [GDT地址]`指令加载进CPU的GDTR寄存器。那么这个时候的寻址方式就变成这样了：
1. 首先代码里的地址都是逻辑地址（也可以叫偏移值，相对于段基址的偏移），寻址的话首先把CS寄存器里的值当做索引去GDT拿表项，表项结构如上图所示。
2. GDT表项里面有段基址，段基址+逻辑地址（偏移值）= 线性地址（虚拟地址）
3. 把线性地址通过下文的内存分页技术划分成3个部分：第1部分指向页目录项（10位，1024项），第2部分指向页表项（10位，一共1024项），第3部分就是页内偏移（12位，4KB的页大小）
4. 转换之后就成了物理地址，送进RAM地址线，打开enable使能位，读取数据。

![地址转换](https://user-images.githubusercontent.com/56379080/145165312-58d12522-55ff-4206-99cb-924b1510ba79.png)

**在Linux 0.11中段基址都是0，所以每个程序的`逻辑地址（程序打印的地址值）= 线性地址`，那他是如何区分多个进程的地址的呢？**<br>
Linux内存映射靠的是页机制。页机制是每个现代CPU都具备的，而段机制是Intel86系架构独有的概念。Linux考虑多平台的移植性，基本没有采用段机制提供的功能，又必须遵守Intel平台先分段再分页及相关权限管理的规则，所以就有了相同的段基址。不同任务之间的地址保护是靠页机制保证的，每个进程对应一套页表，通过对页表的管理实现内存的隔离和共享，只用页机制完全可以实现现代操作系统的内存管理。

**每个进程的逻辑地址是跟进程相关的嘛？因为要通过逻辑地址的前10位去索引页目录表**<br>
参见下面的图13-6，可以看到，代码段起始地址就与任务号有关。

![image](https://user-images.githubusercontent.com/56379080/144188687-8826d2ca-ee6e-4b81-94c7-d26813510f33.png)


**段机制还有什么作用呢？**<br>
CS寄存器值不改变的跳转不需要检查特权级，CS寄存器值改变的跳转一定要检查特权级，特权级放在GDT表项中。

# 主要功能
## Copy On Write技术
1. 为了节约内存，在调用fork（）生成新进程的时候，新进程与原进程会共享同一内存区，只有当其中一进程进行写操作的时候，系统才会为其分配新的内存页面，这就是写时复制（Copy On Write）
2. 两个进程共享一个页面时，这两个进程对这个页面都是只读权限，任一进程进行写操作的时候都会产生页面出错异常中断

## 内存分页
1. 页目录项大小为4B，页表项4B，每页大小4KB。
2. 在Linux 0.11中所有进程共享一个页目录表，每个进程有自己的私有页表。
3. 一个系统中可以有多个页目录表，但某一时刻只能有一个页目录表可用

![image](https://user-images.githubusercontent.com/56379080/144188340-784c4a2f-f4d2-4c94-b405-7f125dec5cc9.png)

**页目录表项结构、页表表项结构**
1. 每个表项由页框地址、访问标志位、脏页标志位、存在标志位构成
2. 页框地址指定了一页内存的物理起始地址
3. 存在位用于标志一个页表项是否可以用于地址转换，任意一级转换过程中的存在位为0都会产生缺页中断，待重新加载页之后就可以重新运行导致异常的指令
4. 已访问位与已修改位都是由CPU置位但不复位，已修改位用于提供页的修改信息；内存管理程序要根据已修改位和已访问位来置换出页，内存管理程序还需要复位这些比特位
5. 读写位、用户/超级用户位用于分页的保护机制，不用于地址转换，但是是在地址转换的时候同时操作的。

![image](https://user-images.githubusercontent.com/56379080/144188555-11841f6a-d3e6-444b-8627-020608ef8bcb.png)

## 内存管理
1. 图13-6中的nr指的是任务号
2. BSS(Block Started by Symbol)段存放的是未初始化变量或者初始值为0的变量，默认初始化为0
3. 数据段存放的是初始化为非0值的变量

![image](https://user-images.githubusercontent.com/56379080/144188718-a76ae5c4-270a-4a78-9691-291461bc5961.png)

## MMU
![image](https://user-images.githubusercontent.com/56379080/145172388-160d3a91-35ee-4455-8092-3742802a5e32.png)

MMU全称Memory Management Unit，即内存管理单元，它存在于CPU中，是一种特化电路，专门用来进行地址转换和权限检查，从而解放CPU的部分算力。操作系统在初始化的时候需要把页表地址传送给MMU，后续地址转换工作都由MMU来完成。

## TLB
TLB (Translation Lookaside Buffers)即转换快表，又简称快表，可以理解为MMU内部专用的存放页表的cache，保存着最近使用的页表项乃至全部页表。MMU接收到虚拟地址后，首先在TLB中查找，如果找到该Virtual Address对应的页表项就直接转换，找不到再去外存页表查找，并置换进TLB。TLB属于片上SRAM，访问速度快，通过TLB缓存页表项可以节省MMU访问外存页表的时间，从而加速虚实地址转换。TLB和CPU cache的工作原理一样，只是TLB专用于为MMU缓存页表。

## Huge Page
在数据库等应用中，有时候为了减少TLB的cache miss，会把页调的大一点，从而使页表项数目更小TLB更能放得下。

# 程序分析
## memory.c
实现了对主内存区内存的动态分配和收回操作，对于内存的管理，内核使用了一个字节数组mem_map[]来表示物理页的状态，其中的值代表引用计数
- get_free_page()用于在主内存区域申请一页空闲内存，并返回物理页的起始地址
- free_page()用于释放指定地址处的一页内存
- copy_page_tables()用于复制指定线性地址和长度内存对应的页目录项和页表，从而实现共享使用
- put_page()用于将一指定的物理内存页面映射到指定的线性地址处
- do_wp_page()是页异常中断函数过程中调用的页写保护函数
- free_page_tables()用于释放指定线性地址的长度对应的物理内存页
- do_no_page()是页异常中断过程中调用的缺页处理函数

**每次访问内存都需要进入内核态吗？**<br>
不是的，只有当产生缺页中断的时候才会进入内核态，一般情况下的访问内存操作都会被MMU截获，从而间接操作内存。想象一下，你想把一个东西存放到A柜子里，然后你让小王帮你存一下，小王发现A柜子不能放东西了，于是给你放到B柜子里了，下次你想取的时候还让小王给你取，取出来交给你就行了。在这个过程中你一直以为你东西放在*A柜子*（虚拟地址）里其实放在*B柜子*（物理地址）里，只不过*小王*(MMU)帮你操作了而已，屏蔽了这一层。

**什么时候产生缺页中断**<br>
- 新申请内存第一次读写（之前申请的时候并没有真正申请，lazy模式分配内存），触发物理内存分配
- 进程fork后子进程写内存触发Copy-On-Write
- 非法内存读写，错误处理。

## page.s
无

