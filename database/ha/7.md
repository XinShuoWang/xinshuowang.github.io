
# （增/删）多节点
## 为什么不能向增删单节点一样？
![image](https://user-images.githubusercontent.com/56379080/184532990-01f084ee-a111-4f24-87b0-83b1752e1e58.png)

如上图所示，如果直接更新配置那么由于不能原子的更新所有的机器，有的机器会有新的配置，而有的机器由于还没来得及更新会有旧的配置，这样就会选举出2个Leader：
```
旧配置: S1 S2 S3
新配置: S1 S2 S3 S4 S5

拥有新配置的机器： S3 S4 S5
拥有旧配置的机器： S1 S2
```
如果在这时候集群Leader下线，触发选举，那么就会使得集群中出现2个Leader：
- 从“拥有新配置的机器”角度来看：集群中有5台机器，而且可以在“拥有新配置的机器”中选举出一个Leader
- 从“拥有旧配置的机器”角度来看：集群中有3台机器，而且可以在“拥有旧配置的机器”中选举出一个Leader

“拥有新配置的机器”不需要“拥有旧配置的机器”的投票，“拥有旧配置的机器”不需要“拥有新配置的机器”的投票，这是选举出2个Leader的根本原因

## 步骤
在单阶段无法完成变更，所以需要两阶段算法来完成变更：

1. Leader收到C<sub>new</sub>的成员变更请求，然后生成一个C<sub>old,new</sub>的ConfChang日志，马上应用该日志，然后将日志通过AppendEntries请求复制到Follower中，收到该ConfChange的节点马上应用该配置作为当前节点的配置
2. 在将C<sub>old,new</sub>日志复制到大多数节点上时，那么C<sub>old,new</sub>的日志就可以提交了，在C<sub>old,new</sub>的ConfChange日志被提交以后，马上创建一个C<sub>new</sub>的ConfChange的日志，并将该日志通过AppendEntries请求复制到Follower中，收到该ConfChange的节点马上应用该配置作为当前节点的配置
3. 一旦C<sub>new</sub>的日志复制到大多数节点上时，那么C<sub>new</sub>的日志就可以提交了，在C<sub>new</sub>日志提交以后，就可以开始下一轮的成员变更了


## 证明
### 在一阶段停机


### 在二阶段停机


### 形象化理解

可以使用下面的方式来形象化理解这个算法：
- 横轴表示的变更时间线
- 纵轴表示的是选举的要求

1. 在更改配置之前，只需要使用Old配置即可完成选举
2. 在更改配置时（两阶段第一阶段）
    - 对于完成配置复制的机器来说，需要使用Old配置+New配置完成选举
    - 对于没有完成配置复制的机器来说，使用Old配置来完成选举
3. 在更改配置完成之后（两阶段第二阶段），只需要使用New配置即可完成选举

```
选举的要求
^
|                       更改配置中
|                          / \
|                         /   \
|                        /     \
|                       /       \
|                      /         \
|       更改配置之前   /           \  更改配置后
|
---------------------------------------------------->  更改配置时间线
```

## 可能存在的问题


