# ACID
- Atomic原子性
- Consistency一致性
- Isolation隔离性
- Durability持久性

# RU
读取未提交（Read uncommitted）：最低级别的隔离，是读取已提交+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（但并未提交，事务B仍在运行中），事务A再次读取数据D时，数据修改是可见的。如果事务B回滚，那么事务A第二次读取的数据D是无意义的，因为那是事务B所做的从未发生的修改（已经回滚了嘛）。这叫脏读（dirty read）。
	- 事务2执行到一半时，事务1 还未提交：事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。
	- 事务2中 第一次读aa 和第二次读aa得到的值是不一样的（事务1未提交），对最新版本的值可见，不隔离已经存在的数据。 不可以重复读，读到的数据是不一样的。如果此时事务1因为其他原因回滚了，事务2第二次读到的数据是无意义的，因为修改没有发生(回滚了)，这叫脏读 。

# RC
读取已提交（Read committed，Oracle、PostgreSQL、SQL Server默认模式）：可重复读+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（或删除）并提交，事务A再次读取数据D时数据的变化（或删除）是可见的。这叫不可重复读（non-repeatable read）。
	- 事务2执行到一半时，事务1 成功提交：事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。
	- 事务2中 第一次读aa 和第二次读aa得到的值是不一样的，对刚提交的值可见，不隔离已经存在的数据。 不可以重复读，读到的数据是不一样的(如果成功修改)。

# RR
可重复读（Repeatable read，MySQL默认模式）：如果一个事务成功执行并且添加了新数据(事务提交)，这些数据对其他正在执行的事务是可见的。但是如果事务成功修改了一条数据，修改结果对正在运行的事务不可见。所以，事务之间只是在新数据方面突破了隔离，对已存在的数据仍旧隔离。
	- 事务2执行到一半时，事务1 成功提交：事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。
	- 事务2中 第一次读aa 和第二次读aa得到的值是一样的，对刚更新的值不可见，隔离已经存在的数据。 可以重复读，读到的数据都是一样的。
    - RC与RR主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。

# Serializable
串行化(Serializable，SQLite默认模式）：最高级别的隔离。两个同时发生的事务100%隔离，每个事务有自己的"世界", 串行执行。
	- 不用解释了，依次执行，不会产生冲突。

![image](https://user-images.githubusercontent.com/56379080/183254439-f2fb5ac1-f957-4e75-89e6-0391d9658e82.png)
