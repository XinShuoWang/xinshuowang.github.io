# 使用方法
- 修饰变量：
  - 局部变量：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。
  - 全局变量：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。
- 修饰函数：
  - 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）
- 修饰类
  - 用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。
  - 用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。


# 初始化时机
全局变量、文件域中的静态变量、类中的成员静态变量在main函数执行前初始化；局部变量中的静态变量在第一次调用时初始化。

使用过类中的静态成员变量的伙伴都发现了，在类中定义的静态成员变量，还必须要在类外定义下才可以使用，否则会编译报错。那么为什么会出现这种情况呢？
静态成员变量不属于任何一个对象，对象的数据中不应该包含静态成员的数据。所以在定义类的时候不会给静态变量分配内存只是声明，因此就要在其他地方分配即定义。
```
#include<bits/stdc++.h>
using namespace std;

class A {
 public:
  A(string s) {
    cout << "Contruct " << s << endl;
  }
};


static A a("a");

void func() {
  static A aa("aa");
}


int main() {
  cout << "1" << endl;
  static A aaa("aaa");
  cout << "2" << endl;
  func();
  return 0;
}

// 输出
Contruct a
1
Contruct aaa
2
Contruct aa
```

# 线程安全问题
全局静态变量在加载的时候就已经初始化，是单线程加载的，所以不会有问题

C++11标准针规定了局部静态变量初始化是线程安全的。这里的线程安全并不是说：由于 m 只能被初始化一次，所以只有初始化 m 的线程会阻塞，另外一个就立即跳过初始化过程返回了。这里的线程安全指的是：一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起。
具体实现如下：局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。然后编译器会生成一个guard_for_c(上述我写的代码中局部静态变量是c) 用来保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。它的最低的一个字节被用作相应静态变量是否已被初始化的标志， 若为 0 表示还未被初始化，否则表示已被初始化( if ((guard_for_bar & 0xff) == 0)判断)。 __cxa_guard_acquire 实际上是一个加锁的过程， 相应的 __cxa_guard_abort 和 __cxa_guard_release 释放锁。
