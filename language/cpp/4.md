# string实现

## COW(Copy On Write)
所谓COW就是指，复制的时候不立即申请新的空间，而是把这一过程延迟到写操作的时候，因为在这之前，二者的数据是完全相同的，无需复制。这其实是一种广泛采用的通用优化策略，它的核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享某些资源，直到有实体需要对资源进行修改时，才真正为该实体分配私有的资源。
COW的实现依赖于引用计数（reference count, rc），初始时rc=1，每次赋值复制时rc++，当修改时，如果rc>1，需要申请新的空间并复制一份原来的数据，并且rc--，当rc==0时，释放原内存。不过，实际的stringCOW实现中，对于什么是”写操作”的认定和我们的直觉是不同的，考虑以下代码：

```
string a = "Hello";
string b = a;
cout << b[0] << endl;
```

以上代码显然没有修改string b的内容，此时似乎a和b是可以共享一块内存的，然而由于string的operator[]和at()会返回某个字符的引用，此时无法准确的判断程序是否修改了string的内容，为了保证COW实现的正确性，string只得统统认定operator[]和at()具有修改的“语义”。
这就导致string的COW实现存在诸多弊端（除了上述原因外，还有线程安全的问题，可进一步阅读文末参考资料），因此只有老版本的GCC编译器和少数一些其他编译器使用了此方式，VS、Clang++、GCC 5.x等编译器均放弃了COW策略，转为使用SSO策略。

## SSO(Small String Optimization)
SSO策略中，拷贝均使用立即复制内存的方法，也就是深拷贝的基本定义，其优化在于，当字符串较短时，直接将其数据存在栈中，而不去堆中动态申请空间，这就避免了申请堆空间所需的开销。

```
int main() {
    string a = "aaaa";
    string b = "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";

    printf("%p ------- %p\n", &a, a.c_str());
    printf("%p ------- %p\n", &b, b.c_str());

    return 0;
}
```

结果：
```
0136F7D0 ------- 0136F7D4
0136F7AC ------- 016F67F0
```
可以看到，a.c_str()的地址与a、b本身的地址较为接近，他们都位于函数的栈空间中，而b.c_str()则离得较远，其位于堆中。
SSO是目前大部分主流STL库的实现方式，其优点就在于，对程序中经常用到的短字符串来说，运行效率较高。
